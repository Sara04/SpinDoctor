function [j] = J_DoublePGSE(lambda, sequence)
%J_DOUBLEPGSE Compute the quantity J(lambda_n, f) for DoublePGSE sequence
%
%   lambda: double
%   sequence: Sequence class
%
%   j: double


d = sequence.delta;
D = sequence.Delta;
tm = sequence.tpause + sequence.delta;

if lambda < 1e-7
    % Use Taylor expansion when lambda is close to 0 
    % to improve numerical stability
    j = lambda - (3 * D^2 * lambda^2) / (3*D - d) ...
        + ((40*D^3 + 5*D*d^2 - d^3 + 30*D^2*tm) * lambda^3) / (20 * (3*D - d)) ...
        - ((4*D^4 + D^2*d^2 + 6*D^3*tm + 3*D^2*tm^2) * lambda^4) / (4 * (3*D - d)) ...
        + ((336*D^5 + 140*D^3*d^2 + 7*D*d^4 - d^5 + 735*D^4*tm ...
            + 105*D^2*d^2*tm + 630*D^3*tm^2 + 210*D^2*tm^3) * lambda^5) / (840 * (3*D - d));
else
    j = - 1 * ( ...
        + exp(-lambda * (2*D + tm - d)) ...
        + exp(-lambda * (2*D + tm + d)) ...
        + exp(-lambda * (tm - d)) ...
        + exp(-lambda * (tm + d)) ...
        - 2 * exp(-lambda * (D + tm - d)) ...
        - 2 * exp(-lambda * (D + tm + d)) ...
        - 2 * exp(-lambda * (2*D + tm)) ...
        + 2 * exp(-lambda * (D - d)) ...
        + 2 * exp(-lambda * (D + d)) ...
        - 2 * exp(-lambda * tm) ...
        + 4 ...
        + 4 * exp(-lambda * (D+tm)) ...
        - 4 * exp(-lambda * D) ...
        - 4 * exp(-lambda * d) ...
        - 4 * lambda * d ) / ...
        (2 * lambda^2 * d^2 * (D - d/3));
end
end

